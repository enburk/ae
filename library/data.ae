using "math";
using math::min;
using math::max;
using math::abs;

operator (x) >>> (f) = f(x);
operator (f) <<< (x) = f(x);

type pointer(x) : ordered =
{
    address : meta::address;
    constructor(x) = address ← meta::address.of(x);
    function value = meta::value.of(x)::at(address);
}

type forward.iterator(x) =
{
    function value → x = {...}
    operator ++ = {...}
}
type bidirectional.iterator(x) : forward.iterator(x) =
{
    function value → x = {...}
    operator ++ = {...}
    operator -- = {...}
}
type random.access.iterator(x) : bidirectional.iterator(x) =
{
    operator ++ = { this += 1 }
    operator -- = { this -= 1 }
    operator += (integer n) = {...}
    operator -= (integer n) = {...}
    operator +  (integer n) = { i := this; i += n; return i }
    operator -  (integer n) = { i := this; i -= n; return i }
    operator -  (same i) → integer = {...}
}
type contiguous.iterator(x) : random.access.iterator(x), ordered =
{
    address : meta::address;
    function value = meta::value.of(x)::at(address);
    operator += (integer n) = { address += n × meta::size.of(x) }
    operator -= (integer n) = { address -= n × meta::size.of(x) }
    operator -  (same i) = (address - i.address) / meta::size.of(x);
}

type range(x) =
{
    type iterator = forward.iterator(x);
    type sentinel = {...}

    function begin → iterator = {...}
    function end   → sentinel = {...}
}

type random.access.range(x) : range(x) =
{
    type iterator = random.access.iterator;
    type sentinel = {...}

    function from (iterator i) → same = {...}
    function upto (iterator i) → same = {...}
    operator [iterator i, iterator j] = from(i).upto(j+1);
    operator [iterator i, iterator j) = from(i).upto(j);

    function from (integer n) = from(begin+n);
    function upto (integer n) = upto(begin+n);
    operator [integer b, integer e] = from(b).upto(e-b+1);
    operator [integer b, integer e) = from(b).upto(e-b);

    operator [integer i] = (begin+i)::value;
    operator (integer i) = (begin+i)::value;
}

type contiguous.range(x) : random.access.range(x) =
{
    type iterator = contiguous.iterator;
    type sentinel = contiguous.iterator;

    detail { begin, end : iterator }
    function begin = detail::begin;
    function end   = detail::end;
    function size  = end - begin;

    function clip (iterator i) = min(max(begin,i),end);
    function from (iterator i) = same(clip(i), end);
    function upto (iterator i) = same(begin, clip(i));
}

type collection(x) : range(x) =
{
    function size → integer = {...}
    operator ~= (x element) = {...}
    operator ~= (range(x) r) = {
        for each e in r do
            this ~= e
    }
}

using R = range(x), C = collection(x)
{
    operator (C left) ~ (x right) = { C c; c ~= left; c ~= right; return c }
    operator (C left) ~ (R right) = { C c; c ~= left; c ~= right; return c }
    operator (C left) ~ (C right) = { C c; c ~= left; c ~= right; return c }
    operator (R left) ~ (C right) = { C c; c ~= left; c ~= right; return c }
    operator (x left) ~ (C right) = { C c; c ~= left; c ~= right; return c }
}

type contiguous.collection(x) : collection(x), random.access.range(x) =
{
    type iterator = contiguous.iterator;
    type sentinel = contiguous.iterator;
    
    function size → integer = {...}
    mutation size ← integer = {...}

    function first = this[0];
    function last  = this[size-1];

    operator ~= (c: collection(x)) =
    {
        i := end;
        size += c.size;
        for each e in c do {
            i::value ← e;
            i++;
        }
    }
    operator ~= (e: x) =
    {
        size++; last = e;
    }
    
    ;; mutation erase = 
}

type contiguous.collection.range(x) : contiguous.range(x) =
{
    collection: pointer(contiguous.collection(x));
    
    ;; mutation erase = 
    ;; mutation replace.by (range x) = 
    ;; mutation replace.by (random.access.range x) = 
}

system
{
    memory
    {
        function request (integer bytes) → contiguous.range(byte) = {...}
        function release (range : contiguous.range(byte)) = {...}
        
        type chunk : contiguous.range(byte) =
        {
            mutation size ← integer = {...}
            destructor = {...}
        }
    }
}

type array(x) : contiguous.collection(x) =
{
    detail { integer size; data: contiguous.range(byte) }
    
    destructor = {
    for each e in this do e::destructor;
    system:memory::release(data); }

    function begin = contiguous.iterator(x)(detail::data::address);
    function end = begin + size;
    
    function from (iterator i) = contiguous.collection.range(x)(clip(i), end);
    function upto (iterator i) = contiguous.collection.range(x)(begin, clip(i));
    
    function size → integer = detail::size;
    mutation size ← integer =
    {
    }
    function capacity → integer = detail::data::size / meta::size.of(x);
    mutation capacity (integer n) = ;;  ← integer n =
    {
        if n < size then return;
        if n = capacity then return;
        new.data := system::memory::request(n × meta::size.of(x));
    ;;  new.data : system::memory::chunk;
    ;;  new.data::size ← n × meta::size.of(x);
        data.copy.to(new.data);
        swap(data, new.data);
    }
}









