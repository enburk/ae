using "math";
using math::min;
using math::max;
using math::abs;

operator (x) >>> (f) = f(x);
operator (f) <<< (x) = f(x);

type pointer(x) : ordered =
{
    address : meta::address;
    constructor(x) = address ← meta::address.of(x);
    function value = meta::value.of(x)::at(address);
}

type forward.iterator(x) =
{
    function value → x = {...}
    operator ++ = {...}
}
type bidirectional.iterator(x) : forward.iterator(x) =
{
    function value → x = {...}
    operator ++ = {...}
    operator -- = {...}
}
type random.access.iterator(x) : bidirectional.iterator(x) =
{
    operator ++ = { this += 1 }
    operator -- = { this -= 1 }
    operator += (integer n) = {...}
    operator -= (integer n) = {...}
    operator +  (integer n) = { i := this; i += n; return i }
    operator -  (integer n) = { i := this; i -= n; return i }
    operator -  (same i) → integer = {...}
}
type contiguous.iterator(x) : random.access.iterator(x), ordered =
{
    address : meta::address;
    function value = meta::value.of(x)::at(address);
    operator += (integer n) = { address += n × meta::size.of(x) }
    operator -= (integer n) = { address -= n × meta::size.of(x) }
    operator -  (same i) = (address - i.address) / meta::size.of(x);
}

type range(x) =
{
    type iterator = forward.iterator(x);
    type sentinel = {...}

    function begin → iterator = {...}
    function end   → sentinel = {...}
}

type random.access.range(x) : range(x) =
{
    type iterator = random.access.iterator;
    type sentinel = {...}

    function from (iterator i) → same = {...}
    function upto (iterator i) → same = {...}
    operator [iterator i, iterator j] = from(i).upto(j+1);
    operator [iterator i, iterator j) = from(i).upto(j);

    function from (integer n) = from(begin+n);
    function upto (integer n) = upto(begin+n);
    operator [integer b, integer e] = from(b).upto(e-b+1);
    operator [integer b, integer e) = from(b).upto(e-b);

    operator [integer i] = (begin+i)::value;
    operator (integer i) = (begin+i)::value;
}

type contiguous.range(x) : random.access.range(x) =
{
    type iterator = contiguous.iterator;
    type sentinel = contiguous.iterator;

    detail { begin, end : iterator }
    function begin = detail::begin;
    function end   = detail::end;
    function size  = end - begin;

    function from (iterator i) = same(i, end);
    function upto (iterator i) = same(begin, i);
}

type collection(x) : range(x) =
{
    function size → integer = {...}
    operator ~= (x element) = {...}
    operator ~= (range(x) r) = {
        for each e in r do
            this ~= e
    }
}

using R = range(x), C = collection(x)
{
    operator (C left) ~ (x right) = { C c; c ~= left; c ~= right; return c }
    operator (C left) ~ (R right) = { C c; c ~= left; c ~= right; return c }
    operator (C left) ~ (C right) = { C c; c ~= left; c ~= right; return c }
    operator (R left) ~ (C right) = { C c; c ~= left; c ~= right; return c }
    operator (x left) ~ (C right) = { C c; c ~= left; c ~= right; return c }
}

type random.access.collection(x) : collection(x), random.access.range(x) =
{
    function size → integer = {...}
    mutation size ← integer = {...}
    
    function first = this[0];
    function last  = this[size-1];

    operator ~= (c: collection(x)) =
    {
        i := end;
        size += c.size;
        for each e in c do {
            i::value ← e;
            i++;
        }
    }
    operator ~= (e: x) =
    {
        size++; last = e;
    }
}

type contiguous.collection.range(x) : contiguous.range(x) =
{
    collection: pointer(contiguous.collection(x));

    function collection → pointer(contiguous.collection(x)) = {...}

    function from (n: integer) = { r := this; r.begin += n; return r }
    function upto (n: integer) = { r := this; r.end = r.begin + n; return r }
    operator [b: integer, e: integer] = {...}
    operator [b: integer, e: integer) = {...}
}

type array(x) : random.access.range(x) =
{
    detail { integer size; data: array.on.heap(value.type) }

    operator [i: integer] = detail::data[i];
    operator (i: integer) = detail::data[i];

    function size → integer = detail::size;
    mutation size ← integer =
    {
    }
    function capacity () = detail::data::size;
    mutation capacity (n: integer) =
    {
        if n < 0 or size < n then return;
        if n = capacity then return;
    ;;  new.data := memory::request(n*meta::size.of(value.type));
        new.data := value.type[n];
        copy(data, new.data);
        swap(data, new.data);
    }
}

type array.on.heap(x) : contiguous.range(x) = ;; of fixed capacity
{
    type iterator = contiguous.iterator;

    data: contiguous.range(byte); ;;x[];

    function begin () = {...}
    function end   () = {...}
    operator [i: integer] = detail::data[i];

    constructor (size: integer = 0) = {
        data = system::memory::request(n*meta::size.of(x));
    }
    destructor = {
        system::memory::release(data);
    }
}

cow.array.on.heap(x) : type = ;; of fixed capacity
{
}






