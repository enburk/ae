type: complex;
type: real     subset.of: complex;
type: rational subset.of: real;
type: integer  subset.of: rational;
type: natural  subset.of: integer;

let: N = natural;
let: Z = integer;
let: Q = rational;
let: R = real;
let: C = complex;

operator: +(N) → N;
operator: +(Z) → Z;
operator: +(Q) → Q;
operator: +(R) → R;
operator: +(C) → C;

operator: -(N) → Z;
operator: -(Z) → Z;
operator: -(Q) → Q;
operator: -(R) → R;
operator: -(C) → C;

operator: (N) + (N) → N;
operator: (N) - (N) → Z;
operator: (N) × (N) → N;
operator: (N) / (N) → Q;  ;; 0?

operator: (Z) + (Z) → Z;
operator: (Z) - (Z) → Z;
operator: (Z) × (Z) → Z;
operator: (Z) / (Z) → Q;  ;; 0?

operator: (Q) + (Q) → Q;
operator: (Q) - (Q) → Q;
operator: (Q) × (Q) → Q;
operator: (Q) / (Q) → Q;  ;; 0?

operator: (R) + (R) → R;
operator: (R) - (R) → R;
operator: (R) × (R) → R;
operator: (R) / (R) → R;  ;; 0?

operator: (C) + (C) → C;
operator: (C) - (C) → C;
operator: (C) × (C) → C;
operator: (C) / (C) → C;  ;; 0?

;; system

type: address subset.of: natural;

type: value.of(type: x)
{
    function: at (address) → x;
}

type: pointer (type: x)
{
    address address;
    property: value → x = value.of(x)::at(address);
    property: value ← x = value.of(x)::at(address) ← value;
}
