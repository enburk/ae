import: ::numerals;

type: rational narrows: real
{
    int a; let: numerator   = a;
    int b; let: denominator = b;

    invariant: b ≠ 0;

    property: real;
    coerse:; ;; rational → real

    operator: = (.same x) = a × x.b = b × x.a;
    operator: < (.same x) =
        b > 0 and x.b > 0 or
        b < 0 and x.b < 0 ?
        a × x.b < b × x.a |
        a × x.b > b × x.a;

    operator: + (.same x) = .same(a × x.b + b × x.a, b × x.b);
    operator: - (.same x) = .same(a × x.b - b × x.a, b × x.b);
    operator: × (.same x) = .same(a × x.a,  b × x.b);
    operator: / (.same x) = .same(a × x.b,  b × x.a);

    operator: ^ (int n) = n < 0 ? .same(b^n, a^n) | .same(a^n, b^n);

    function: canonicalize
    {
        x := gcd(a, b);
        a /= x, b /= x;
        if: b < 0 then:
        a ← -a, b ← -b;
        return: void;
    }
    property: canonical
    {
        x := .self;
        x.canonicalize();
        return: x;
    }
}

operator: - (rational x) = rational(-x.a, x.b);

type: integer extension:
{
    property: rational = rational(self::value, 1);
}