nothing {}
;; - also known as "unit type"
;; - singleton (type and value)
;; - all other types extends it
;; - nothing ≠ any: nothing also
;;   can be constructed from any type
;;   but only by slicing (to nothing)

type: void;
;; - also known as "bottom type"
;; - no value can be instantiated
;; - inherits all other types

function: absurd (void) → x;
;; since void values logically don't exist,
;; this witnesses the logical reasoning tool
;; of "ex falso quodlibet"
;; (Haskell)


type: boolean = false | true; ;; ordered?

let: false = boolean::false;
let: true  = boolean::true;

operator: not (boolean x) = x = true;
operator: (boolean x) or  (boolean y) = x ? true | y;
operator: (boolean x) and (boolean y) = x ? y | false;
operator: (boolean x) xor (boolean y) = x and not y or y and not x; 

operator: (x a) = (x b); ;; element-wise by default
operator: (x a) < (x b); ;; lexicographical by default
operator: (x a) ≠ (x b) = not (a = b);
operator: (x a) > (x b) = not (a ≤ b);
operator: (x a) ≤ (x b) = a < b or a = b;
operator: (x a) ≥ (x b) = a > b or a = b;

type: predicate (args…) = function: (args…) → boolean;

type: x extension:
{
    property: .self → x;
    property: .self ← x;
    property: .same → type: x;
}

;; unary operators precede binary operators
;; postfix operators precede prefix operators
;; postfix operators are left associative
;; prefix operators are right associative
;; infix operators are left associative (by default?)
;; infix operators have precedence

operator: ^ precede: ×, /;
operator: × precede: +, -;
operator: / precede: +, -;

operator: (x) += (y) { x ← x + y }
operator: (x) -= (y) { x ← x - y }
operator: (x) ×= (y) { x ← x × y }
operator: (x) /= (y) { x ← x / y }

;; bitand bitor bitxor