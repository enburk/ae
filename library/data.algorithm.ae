using "math";
using math::min;
using math::max;
using math::abs;

type predicate (args...)     = function (args...) → boolean;
type binary.predicate (x, y) = function (x, y) → boolean;
type unary.predicate (x)     = function (x) → boolean;

mutation swap (a, b) = { c := a; a ← b; b ← c }

type range(x) extension =
{
    mutation remove.if (match: unary.predicate(x)) =
    {
        i := begin;
        j := begin;
        while j ≠ end do {
            swap(i.value, j.value);
            if not match(i.value) then i++;
            j++;
        }
        return i;
    }
}

type bidirectional.range(x) extension =
{
    mutation bubble.sort (in.order: binary.predicate = ≤) =
    {
        b := begin;
        e := end;
        while b ≠ e do {
            i := b;
            j := b; j++;
            while j ≠ e do {
                if not in.order(i::value, j::value)
                      then swap(i::value, j::value);
                i++;
                j++;
            }
            e--;
        }
    }
}
    
type random.access.range(x) extension =
{
    mutation rotate.by.reverse (middle: iterator) =
    {
        reverse(begin,  middle);
        reverse(middle, end);
        reverse(begin,  end);

        middle = begin + (end - middle);

        return middle;
    }
    
    mutation stable.partition (match: unary.predicate(x)) =
    {
        n := end - begin;
        if n = 0 then return begin;
        if n = 1 then return begin + integer(match(begin.value));
        
        middle := begin + n/2;
        
        return random.access.range
        (
            this[begin, middle)::stable.partition(match),
            this[middle,   end)::stable.partition(match)
        )
        ::rotate(middle);
    } 
    
    mutation gather (place: iterator, match: unary.predicate(x)) =
    {
        return random.access.range
        (
            this[begin, place)::stable_partition(negate(match)),
            this[place,   end)::stable_partition(match)
        )
    }
}








