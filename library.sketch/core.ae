type: type;

operation: (boolean q) ? {x} | {y};

operator (type x) [] → contiguous.range(x);

type: boolean = {false, true}

operator: (x a) = (y b) = b = a;
operator: (x a) < (y b) = b > a;
operator: (x a) ≠ (y b) = b ≠ a;
operator: (x a) > (y b) = b < a;
operator: (x a) ≤ (y b) = b ≥ a;
operator: (x a) ≥ (y b) = b ≤ a;

operator: (x a) = (y b) requires: x ≠ y = b = a;
operator: (x a) < (y b) requires: x ≠ y = b > a;
operator: (x a) ≠ (y b) requires: x ≠ y = b ≠ a;
operator: (x a) > (y b) requires: x ≠ y = b < a;
operator: (x a) ≤ (y b) requires: x ≠ y = b ≥ a;
operator: (x a) ≥ (y b) requires: x ≠ y = b ≤ a;

assert: (a = b) <=> (b = a);
assert: (a < b) <=> (b > a);
assert: (a ≠ b) <=> (b ≠ a);
assert: (a > b) <=> (b < a);
assert: (a ≤ b) <=> (b ≥ a);
assert: (a ≥ b) <=> (b ≤ a);

assert: (a = b) ⇔ (b = a);
assert: (a < b) ⇔ (b > a);
assert: (a ≠ b) ⇔ (b ≠ a);
assert: (a > b) ⇔ (b < a);
assert: (a ≤ b) ⇔ (b ≥ a);
assert: (a ≥ b) ⇔ (b ≤ a);

assert: (a = b) ↔ (b = a);
assert: (a < b) ↔ (b > a);
assert: (a ≠ b) ↔ (b ≠ a);
assert: (a > b) ↔ (b < a);
assert: (a ≤ b) ↔ (b ≥ a);
assert: (a ≥ b) ↔ (b ≤ a);

operator: (Z) ←= (Q);
operator: (Z) ←= (R);
operator: (Z) ←≈ (R);

operator: (R) ≈ (R) → boolean;

type: rational narrows: real narrowed.by: int
{
    int a := 0; let: numerator   = a;
    int b := 1; let: denominator = b;

    coercion: → real = real(a) / real(b);
    coercion: ← int x = { a ← x; b ← 1 };
}

type: ordered
{
    operator: = (.same x) = .self <=> x = strong.order::equivalent;
    …
}

type: shelter (type: x extends: animal)
{
    function: get → x;
    function: put(x);
}
type: cat_shelter extends: shelter(cat)
{
    function: get → cat;
    function: put(cat);
}

integral: type = I or Z or Q or R or C;

x₀ 1.25×10⁵

1010003111₂₂
AF456₁₆ a₁₆
AF456:16

type: ordered
{
    operator: < (same: x);
    operator: ≤ (same: x) = not
    operator: > (same: x)
    operator: ≥ (same: x)
}

break!
continue!
break:break:

let:
x = something;
x = case1 ? do1 |
x = case2 ? do2 |
    otherwise;

let:
x = something;
x = case1 ? do1 else:
x = case2 ? do2 else:
    otherwise;

let:
x = something;
x = case1 ?
{
    do1.1;
    do1.2;
}
else:
x = case2 ?
{
    do2.1;
    do2.2;
}
else:
{
    otherwise;
}

operator: (boolean x) nand (boolean y) = x ? true | y ? false | true;
operator: not (boolean x) = nand(x,x);
operator: (boolean x) and (boolean y) = not (x nand y);


function Z (N) = …
function Q (Z) = …
function R (Q) = …
function C (R) = …

operator (N) mod (N) → N
operator (Z) mod (Z) → Z

operator (x) / (y) = (x) : (y)

operator (numeric x) / (numeric y) = x : y

axiom (Z a, b, c): a + (b + c) = (a + b) + c

axiom: N is semiring



operator (x) >>> (f) = f(x)
operator (f) <<< (x) = f(x)

operator (x) >>> (f) : f(x)
operator (f) <<< (x) : f(x)

operator (x):(y) = ratio(x, y)

operator a:a ::
operator x:y = ratio x y

;; operator if (x) then (y) else (z) ;; = x ? y : z
;; {
;;     if x
;;     then return y;
;;     else return z;
;; }

;; operator (f) if (x) else (g) = ;; python

;; operator if (x) then (y) elif (z) then (a) … else (b) =













