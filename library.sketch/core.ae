contiguous.range (type x) : type
    function data →
    function size → int

operator (type x) [] → contiguous.range(x);

type: boolean = {false, true}

boolean: type = {true, false};
integral: type = I or Z or Q or R or C;

let: int  = integer;
let: bool = boolean;

x₀ 1.25×10⁵

1010003111₂₂
AF456₁₆ a₁₆
AF456:16

type: ordered
{
    operator: < (same: x);
    operator: ≤ (same: x) = not
    operator: > (same: x)
    operator: ≥ (same: x)
}


let:
x = something;
x = case1 ? do1 |
x = case2 ? do2 |
    otherwise;

let:
x = something;
x = case1 ? do1 else:
x = case2 ? do2 else:
    otherwise;

let:
x = something;
x = case1 ?
{
    do1.1;
    do1.2;
}
else:
x = case2 ?
{
    do2.1;
    do2.2;
}
else:
{
    otherwise;
}

operator if (x) = (if x = true)
operator (x) ?  = (if x = true)

type integral

type integer.8
type integer.16
type integer.32
type integer.64


operator (x) = (x) = …

function Z (N) = …
function Q (Z) = …
function R (Q) = …
function C (R) = …

operator (N) mod (N) → N
operator (Z) mod (Z) → Z

operator (x) / (y) = (x) : (y)

operator (numeric x) / (numeric y) = x : y

axiom (Z a, b, c): a + (b + c) = (a + b) + c

axiom: N is semiring



operator (x) >>> (f) = f(x)
operator (f) <<< (x) = f(x)

operator (x) >>> (f) : f(x)
operator (f) <<< (x) : f(x)

operator (x):(y) = ratio(x, y)

operator a:a ::
operator x:y = ratio x y

;; operator if (x) then (y) else (z) ;; = x ? y : z
;; {
;;     if x
;;     then return y;
;;     else return z;
;; }

;; operator (f) if (x) else (g) = ;; python

;; operator if (x) then (y) elif (z) then (a) … else (b) =













